{"version":3,"sources":["utils.js","index.js"],"names":["calculateWinner","squares","lines","i","length","a","b","c","Square","props","className","onClick","value","Board","this","winner","includes","looper","Array","fill","map","_","row","col","renderSquare","React","Component","Game","state","history","position","stepNumber","xIsNext","isStepsReverse","slice","concat","setState","step","reverse","status","nextClass","current","winnerIndex","isDraw","moves","move","index","display_moves","desc","Math","floor","jumpTo","reverseButton","player","name","handleClick","reverseSteps","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9fb4d772.chunk.js","sourcesContent":["// 通过数组排布获取棋子的行数和列数\r\nexport function getPosition(index) {\r\n  if (typeof index !== 'number' || index < 0 || index > 9) {\r\n    return '';\r\n  }\r\n  let row = Math.floor(index / 3) + 1, col = index % 3 + 1;\r\n  let position = '(' + col + ', ' + row + ')';\r\n  return position;\r\n}\r\n\r\n\r\n// 判断胜者\r\nexport function calculateWinner(squares) {\r\n  // 获胜的序号\r\n  const lines = [\r\n    [0, 1, 2],\r\n    [3, 4, 5],\r\n    [6, 7, 8],\r\n    [0, 3, 6],\r\n    [1, 4, 7],\r\n    [2, 5, 8],\r\n    [0, 4, 8],\r\n    [2, 4, 6],\r\n  ];\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const [a, b, c] = lines[i];\r\n    // 有人获胜\r\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\r\n      // 返回赢者数组\r\n      return lines[i];\r\n      // return squares[a];\r\n    }\r\n  }\r\n  return null;\r\n}\r\n","// 导入库\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n// 导入样式\r\nimport \"./index.css\";\r\nimport { getPosition, calculateWinner } from './utils.js';\r\n\r\n// Square 组件渲染了一个单独的 <button>\r\n// 组件只包含一个 render 方法，并且不包含 state，那么使用函数组件简化。父组件引入后，Square组件不需要再保存游戏的 state\r\nfunction Square(props) {\r\n  return (\r\n    // 接收父组件参数\r\n    <button className={props.className} onClick={props.onClick}>\r\n      {props.value}\r\n    </button>\r\n  );\r\n}\r\n\r\n// Board 组件渲染了 9 个方块\r\nclass Board extends React.Component {\r\n  // 将Board中的数据转移至Game父组件，无Constructor\r\n  // 渲染棋盘\r\n  renderSquare(i) {\r\n    // return <Square />;\r\n    let className = this.props.winner ?\r\n      this.props.winner.includes(i) ?\r\n        'square win' : 'square' : 'square';\r\n    if (this.props.squares[i] === 'X') className += ' player1';\r\n    if (this.props.squares[i] === 'O') className += ' player2';\r\n    // 增加参数，修改一下 Square 的点击事件监听函数\r\n    return (\r\n      <Square\r\n        // 从 Game 组件中接收 squares 和 onClick 这两个 props。\r\n        key={i % 3 + 1}\r\n        value={this.props.squares[i]}\r\n        className={className}\r\n        onClick={() => this.props.onClick(i)}\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    // 移到Game组件\r\n    // 渲染改为行列循环遍历\r\n    const n = 3;\r\n    const looper = Array(n).fill().map((_, i) => i + 1);\r\n    return (\r\n      <div>\r\n        {looper.map(row => {\r\n          return (\r\n            <div key={row} className=\"board-row\">\r\n              {\r\n                looper.map(col => {\r\n                  return this.renderSquare((row - 1) * 3 + col - 1);\r\n                })\r\n              }\r\n            </div>\r\n          )\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// Game 组件渲染了含有默认值的一个棋盘\r\nclass Game extends React.Component {\r\n  // 点击事件\r\n  handleClick(i) {\r\n    // 历史，丢弃stepNumber后的数据，注意反向后的表达式\r\n    let history = this.state.isStepsReverse ? this.state.history.slice(this.state.stepNumber) : this.state.history.slice(0, this.state.stepNumber + 1);\r\n    // 当前状态\r\n    const current = this.state.isStepsReverse ? history[0] : history[history.length - 1];\r\n    const squares = current.squares.slice();\r\n    // 当有玩家胜出时，或者某个 Square 已经被填充时，该函数不做任何处理直接返回\r\n    if (calculateWinner(squares) || squares[i]) return;\r\n    // 根据xIsNext判断\r\n    squares[i] = this.state.xIsNext ? \"X\" : \"O\";\r\n    // 拼接历史列表\r\n    history = this.state.isStepsReverse ?\r\n      [\r\n        {\r\n          squares: squares,\r\n          position: i\r\n        },\r\n      ].concat(history.slice()) :\r\n      history.slice().concat([\r\n        {\r\n          squares: squares,\r\n          position: i\r\n        },\r\n      ]);\r\n    const stepNumber = this.state.isStepsReverse ? 0 : history.length - 1;\r\n    this.setState({\r\n      history,\r\n      // squares: squares,\r\n      // 更新时间步\r\n      stepNumber,\r\n      // 翻转xIsNext\r\n      xIsNext: !this.state.xIsNext,\r\n    });\r\n  }\r\n\r\n  // 更新状态 stepNumber\r\n  jumpTo(step) {\r\n    this.setState({\r\n      stepNumber: step,\r\n      xIsNext: step % 2 === 0,\r\n    });\r\n  }\r\n\r\n  // 反转历史记录\r\n  reverseSteps() {\r\n    this.setState({\r\n      history: this.state.history.slice().reverse(),\r\n      isStepsReverse: !this.state.isStepsReverse,\r\n      stepNumber: this.state.history.length - 1 - this.state.stepNumber,\r\n    })\r\n  }\r\n  // 为 Game 组件添加构造函数，保存历史步骤列表\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      history: [\r\n        {\r\n          squares: Array(9).fill(null),\r\n          // 记录每个操作的位置\r\n          position: null,\r\n        },\r\n      ],\r\n      // 步数\r\n      stepNumber: 0,\r\n      // 将 “X” 默认设置为先手棋\r\n      xIsNext: true,\r\n      // 历史步骤是否逆序\r\n      isStepsReverse: false\r\n    };\r\n  }\r\n\r\n  render() {\r\n    // 状态变化，从子组件提升到父组件\r\n    // 历史\r\n    const history = this.state.history;\r\n    // 当前状态，将代码从始终根据最后一次移动渲染修改为根据当前 stepNumber 渲染\r\n    const current = history[this.state.stepNumber];\r\n    // 计算胜者\r\n    const winnerIndex = calculateWinner(current.squares);\r\n    const winner = winnerIndex ? current.squares[winnerIndex[0]] : null;\r\n    // 计算平局\r\n    const isDraw = !winner && !current.squares.includes(null);\r\n    // 历史步骤映射为代表按钮的 React 元素，然后可以展示出一个按钮的列表，点击这些按钮，可以“跳转”到对应的历史步骤。\r\n    const moves = history.map((step, move) => {\r\n      const display_moves = this.state.isStepsReverse ? history.length - move - 1 : move;\r\n      const desc = display_moves ? \"跳转至第\" + display_moves + \"步\" : \"游戏重新开始\";\r\n      let className = move === step ? 'current-step' : '';\r\n      const position = getPosition(step.position);\r\n      return (\r\n        // 组件的 key 值并不需要在全局都保证唯一，只需要在当前的同一级元素之前保证唯一即可\r\n        <li key={move}>\r\n          <button className={className} onClick={() => this.jumpTo(move)}>{desc}{position}</button>\r\n        </li>\r\n      );\r\n    });\r\n    // 状态\r\n    let status;\r\n    let nextClass;\r\n    // 判断是否获胜\r\n    if (winner) {\r\n      status = \"胜者：\" + winner;\r\n      nextClass = winner === \"X\" ? \"player1\" : \"player2\";\r\n    } else if (isDraw) {\r\n      status = \"平局\";\r\n      nextClass = \"draw\";\r\n    } else {\r\n      status = \"下一步: \" + (this.state.xIsNext ? \"X\" : \"O\");\r\n      nextClass = this.state.xIsNext ? \"player1\" : \"player2\";\r\n    }\r\n    let players = [{\r\n      \"className\": \"player1\",\r\n      \"name\": \"玩家1:X\"\r\n    }, {\r\n      \"className\": \"player2\",\r\n      \"name\": \"玩家2:O\"\r\n    }];\r\n    // 状态\r\n    const isStepsReverse = this.state.isStepsReverse;\r\n    let reverseButton = isStepsReverse ? \"历史记录逆序\" : \"历史记录顺序\";\r\n\r\n    return (\r\n      <div className=\"game\">\r\n        <div className=\"game-board\">\r\n          <div className=\"game-title\">\r\n            {players.map((player) => {\r\n              return (<div className={player.className} key={player.className}>\r\n                {player.name}\r\n              </div>)\r\n            })}\r\n          </div>\r\n          <Board\r\n            // 绑定参数和事件\r\n            winner={winnerIndex}\r\n            squares={current.squares}\r\n            onClick={(i) => this.handleClick(i)}\r\n          />\r\n        </div>\r\n        <div className=\"game-info\">\r\n          <div className={nextClass + ' status'}>{status}</div>\r\n          <button className=\"reverse-steps\" onClick={() => { this.reverseSteps() }}>{reverseButton}</button>\r\n          <ol className=\"history-list\">{moves}</ol>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(<Game />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}