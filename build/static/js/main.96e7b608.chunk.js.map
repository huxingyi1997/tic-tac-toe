{"version":3,"sources":["index.js"],"names":["Square","props","className","onClick","value","Board","i","this","squares","renderSquare","React","Component","Game","state","history","Array","fill","stepNumber","xIsNext","slice","length","calculateWinner","setState","concat","step","status","current","winner","moves","map","move","desc","jumpTo","handleClick","lines","a","b","c","ReactDOM","render","document","getElementById"],"mappings":"kOAuCA,SAASA,EAAOC,GACd,OACE,wBAAQC,UAAU,SAASC,QAASF,EAAME,QAA1C,SACGF,EAAMG,Q,IAMPC,E,kKA2BJ,SAAaC,GAAI,IAAD,OAGd,OACE,cAACN,EAAD,CAIEI,MAAOG,KAAKN,MAAMO,QAAQF,GAC1BH,QAAS,kBAAM,EAAKF,MAAME,QAAQG,Q,oBAKxC,WAeE,OACE,gCACE,sBAAKJ,UAAU,YAAf,UACGK,KAAKE,aAAa,GAClBF,KAAKE,aAAa,GAClBF,KAAKE,aAAa,MAErB,sBAAKP,UAAU,YAAf,UACGK,KAAKE,aAAa,GAClBF,KAAKE,aAAa,GAClBF,KAAKE,aAAa,MAErB,sBAAKP,UAAU,YAAf,UACGK,KAAKE,aAAa,GAClBF,KAAKE,aAAa,GAClBF,KAAKE,aAAa,a,GAvETC,IAAMC,WA+EpBC,E,kDAmCJ,WAAYX,GAAQ,IAAD,8BACjB,cAAMA,IACDY,MAAQ,CACXC,QAAS,CACP,CACEN,QAASO,MAAM,GAAGC,KAAK,QAI3BC,WAAY,EAEZC,SAAS,GAXM,E,+CAjCnB,SAAYZ,GAEV,IAAMQ,EAAUP,KAAKM,MAAMC,QAAQK,MAAM,EAAGZ,KAAKM,MAAMI,WAAa,GAG9DT,EADUM,EAAQA,EAAQM,OAAS,GACjBZ,QAAQW,QAE5BE,EAAgBb,IAAYA,EAAQF,KAExCE,EAAQF,GAAKC,KAAKM,MAAMK,QAAU,IAAM,IACxCX,KAAKe,SAAS,CACZR,QAASA,EAAQS,OAAO,CACtB,CACEf,QAASA,KAKbS,WAAYH,EAAQM,OAEpBF,SAAUX,KAAKM,MAAMK,a,oBAKzB,SAAOM,GACLjB,KAAKe,SAAS,CACZL,WAAYO,EACZN,QAASM,EAAO,IAAM,M,oBAoB1B,WAAU,IAoBJC,EApBG,OAGDX,EAAUP,KAAKM,MAAMC,QAErBY,EAAUZ,EAAQP,KAAKM,MAAMI,YAE7BU,EAASN,EAAgBK,EAAQlB,SAGjCoB,EAAQd,EAAQe,KAAI,SAACL,EAAMM,GAC/B,IAAMC,EAAOD,EAAO,2BAASA,EAAO,SAAM,uCAC1C,OAEE,aADA,CACA,eACE,wBAAQ3B,QAAS,kBAAM,EAAK6B,OAAOF,IAAnC,SAA2CC,KADpCD,MAcb,OALEL,EADEE,EACO,qBAAQA,EAER,wBAAWpB,KAAKM,MAAMK,QAAU,IAAM,KAI/C,sBAAKhB,UAAU,OAAf,UACE,qBAAKA,UAAU,aAAf,SACE,cAACG,EAAD,CAEEG,QAASkB,EAAQlB,QACjBL,QAAS,SAACG,GAAD,OAAO,EAAK2B,YAAY3B,QAGrC,sBAAKJ,UAAU,YAAf,UACE,8BAAMuB,IACN,6BAAKG,c,GAzFIlB,IAAMC,WAqGzB,SAASU,EAAgBb,GAYvB,IAVA,IAAM0B,EAAQ,CACZ,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAEA5B,EAAI,EAAGA,EAAI4B,EAAMd,OAAQd,IAAK,CAAC,IAAD,cACnB4B,EAAM5B,GADa,GAC9B6B,EAD8B,KAC3BC,EAD2B,KACxBC,EADwB,KAGrC,GAAI7B,EAAQ2B,IAAM3B,EAAQ2B,KAAO3B,EAAQ4B,IAAM5B,EAAQ2B,KAAO3B,EAAQ6B,GACpE,OAAO7B,EAAQ2B,GAGnB,OAAO,KAtBTG,IAASC,OAAO,cAAC3B,EAAD,IAAU4B,SAASC,eAAe,W","file":"static/js/main.96e7b608.chunk.js","sourcesContent":["// 导入库\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n// 导入样式\r\nimport \"./index.css\";\r\n\r\n// Square 组件渲染了一个单独的 <button>\r\n// class Square extends React.Component {\r\n//   // 添加一个构造函数，用来初始化 state\r\n//   // constructor(props) {\r\n//   //   // 每次你定义其子类的构造函数时，都需要调用 super 方法。因此，在所有含有构造函数的的 React 组件中，构造函数必须以 super(props) 开头。\r\n//   //   super(props);\r\n//   //   this.state = {\r\n//   //     value: null,\r\n//   //   };\r\n//   // }\r\n//   // 父组件引入后，Square组件不需要再保存游戏的 state\r\n\r\n//   render() {\r\n//     return (\r\n//       //   <button className=\"square\" onClick={function() {alert('click'); }}>\r\n//       // 为了避免 this 造成的困扰，我们在这里使用箭头函数 来进行事件处理\r\n//       //   <button className=\"square\" onClick={() => alert(\"click\")}>\r\n//       // 次在组件中调用 setState 时，React 都会自动更新其子组件\r\n//       // <button className=\"square\" onClick={() => this.setState({ value: \"X\" })}>\r\n//       // 接收父组件参数\r\n//       <button className=\"square\" onClick={() => this.props.onClick()}>\r\n//         {/* 参数 */}\r\n//         {/* 原本是固定参数 */}\r\n//         {/* {this.props.value} */}\r\n//         {/* 改为变化参数 */}\r\n//         {/* {this.state.value} */}\r\n//         {/* 使用父组件参数 */}\r\n//         {this.props.value}\r\n//       </button>\r\n//     );\r\n//   }\r\n// }\r\n// 组件只包含一个 render 方法，并且不包含 state，那么使用函数组件简化\r\nfunction Square(props) {\r\n  return (\r\n    <button className=\"square\" onClick={props.onClick}>\r\n      {props.value}\r\n    </button>\r\n  );\r\n}\r\n\r\n// Board 组件渲染了 9 个方块\r\nclass Board extends React.Component {\r\n  // 将Board中的数据转移至Game父组件\r\n  // // 为 Board 组件添加构造函数，将 Board 组件的初始状态设置为长度为 9 的空值数组\r\n  // constructor(props) {\r\n  //   super(props);\r\n  //   this.state = {\r\n  //     squares: Array(9).fill(null),\r\n  //     // 将 “X” 默认设置为先手棋\r\n  //     xIsNext: true,\r\n  //   };\r\n  // }\r\n\r\n  // 移至Game组件\r\n  // 点击事件\r\n  // handleClick(i) {\r\n  //   const squares = this.state.squares.slice();\r\n  //   // 当有玩家胜出时，或者某个 Square 已经被填充时，该函数不做任何处理直接返回\r\n  //   if (calculateWinner(squares) || squares[i]) return;\r\n  //   // 根据xIsNext判断\r\n  //   squares[i] = this.state.xIsNext ? \"X\" : \"O\";\r\n  //   this.setState({\r\n  //     squares: squares,\r\n  //     // 翻转xIsNext\r\n  //     xIsNext: !this.state.xIsNext,\r\n  //   });\r\n  // }\r\n\r\n  renderSquare(i) {\r\n    // return <Square />;\r\n    // 增加参数，修改一下 Square 的点击事件监听函数\r\n    return (\r\n      <Square\r\n        // value={this.state.squares[i]}\r\n        // onClick={() => this.handleClick(i)}\r\n        // 从 Game 组件中接收 squares 和 onClick 这两个 props。\r\n        value={this.props.squares[i]}\r\n        onClick={() => this.props.onClick(i)}\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    // 移到Game组件\r\n    // // // 状态变化\r\n    // // const status = \"Next player: \" +  (this.state.xIsNext ? \"X\" : \"O\");\r\n    // // 计算胜者\r\n    // const winner = calculateWinner(this.state.squares);\r\n    // // 状态\r\n    // let status;\r\n    // // 判断是否获胜\r\n    // if (winner) {\r\n    //   status = '胜者：' + winner;\r\n    // } else {\r\n    //   status = \"下一步: \" +  (this.state.xIsNext ? \"X\" : \"O\");\r\n    // }\r\n\r\n    return (\r\n      <div>\r\n        <div className=\"board-row\">\r\n          {this.renderSquare(0)}\r\n          {this.renderSquare(1)}\r\n          {this.renderSquare(2)}\r\n        </div>\r\n        <div className=\"board-row\">\r\n          {this.renderSquare(3)}\r\n          {this.renderSquare(4)}\r\n          {this.renderSquare(5)}\r\n        </div>\r\n        <div className=\"board-row\">\r\n          {this.renderSquare(6)}\r\n          {this.renderSquare(7)}\r\n          {this.renderSquare(8)}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// Game 组件渲染了含有默认值的一个棋盘\r\nclass Game extends React.Component {\r\n  // 点击事件\r\n  handleClick(i) {\r\n    // 历史,丢弃stepNumber后的数据\r\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\r\n    // 当前状态\r\n    const current = history[history.length - 1];\r\n    const squares = current.squares.slice();\r\n    // 当有玩家胜出时，或者某个 Square 已经被填充时，该函数不做任何处理直接返回\r\n    if (calculateWinner(squares) || squares[i]) return;\r\n    // 根据xIsNext判断\r\n    squares[i] = this.state.xIsNext ? \"X\" : \"O\";\r\n    this.setState({\r\n      history: history.concat([\r\n        {\r\n          squares: squares,\r\n        },\r\n      ]),\r\n      // squares: squares,\r\n      // 更新时间步\r\n      stepNumber: history.length,\r\n      // 翻转xIsNext\r\n      xIsNext: !this.state.xIsNext,\r\n    });\r\n  }\r\n\r\n  // 更新状态 stepNumber\r\n  jumpTo(step) {\r\n    this.setState({\r\n      stepNumber: step,\r\n      xIsNext: step % 2 === 0,\r\n    });\r\n  }\r\n\r\n  // 为 Game 组件添加构造函数，保存历史步骤列表\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      history: [\r\n        {\r\n          squares: Array(9).fill(null),\r\n        },\r\n      ],\r\n      // 步数\r\n      stepNumber: 0,\r\n      // 将 “X” 默认设置为先手棋\r\n      xIsNext: true,\r\n    };\r\n  }\r\n\r\n  render() {\r\n    // // 状态变化，从子组件提升到父组件\r\n    // 历史\r\n    const history = this.state.history;\r\n    // 当前状态，将代码从始终根据最后一次移动渲染修改为根据当前 stepNumber 渲染\r\n    const current = history[this.state.stepNumber];\r\n    // 计算胜者\r\n    const winner = calculateWinner(current.squares);\r\n\r\n    // 历史步骤映射为代表按钮的 React 元素，然后可以展示出一个按钮的列表，点击这些按钮，可以“跳转”到对应的历史步骤。\r\n    const moves = history.map((step, move) => {\r\n      const desc = move ? \"跳转至第\" + move + \"步\" : \"游戏重新开始\";\r\n      return (\r\n        // 组件的 key 值并不需要在全局都保证唯一，只需要在当前的同一级元素之前保证唯一即可\r\n        <li key={move}>\r\n          <button onClick={() => this.jumpTo(move)}>{desc}</button>\r\n        </li>\r\n      );\r\n    });\r\n    // 状态\r\n    let status;\r\n    // 判断是否获胜\r\n    if (winner) {\r\n      status = \"胜者：\" + winner;\r\n    } else {\r\n      status = \"下一步: \" + (this.state.xIsNext ? \"X\" : \"O\");\r\n    }\r\n\r\n    return (\r\n      <div className=\"game\">\r\n        <div className=\"game-board\">\r\n          <Board\r\n            // 绑定参数和事件\r\n            squares={current.squares}\r\n            onClick={(i) => this.handleClick(i)}\r\n          />\r\n        </div>\r\n        <div className=\"game-info\">\r\n          <div>{status}</div>\r\n          <ol>{moves}</ol>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(<Game />, document.getElementById(\"root\"));\r\n\r\n// 判断胜者\r\nfunction calculateWinner(squares) {\r\n  // 获胜的序号\r\n  const lines = [\r\n    [0, 1, 2],\r\n    [3, 4, 5],\r\n    [6, 7, 8],\r\n    [0, 3, 6],\r\n    [1, 4, 7],\r\n    [2, 5, 8],\r\n    [0, 4, 8],\r\n    [2, 4, 6],\r\n  ];\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const [a, b, c] = lines[i];\r\n    // 有人获胜\r\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\r\n      return squares[a];\r\n    }\r\n  }\r\n  return null;\r\n}\r\n"],"sourceRoot":""}